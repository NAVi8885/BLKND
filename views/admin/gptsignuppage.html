<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Sign Up - BLKND</title>

  <!-- Bootstrap + icons (kept) -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css">

  <style>
    /* page basics (kept from your original) */
    body {
      font-family: 'Jost', sans-serif;
      margin: 0;
      height: 100vh;
      overflow: hidden; /* we'll control scrolling if needed */
      background: #06070a; /* fallback */
    }

    /* canvas wrapper sits behind content */
    #galaxy-canvas-wrap {
      position: fixed;
      inset: 0;
      z-index: 0;
      pointer-events: none; /* allow clicks through to form */
    }

    /* keep your signup container above the canvas */
    .signup-container {
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 40px 0;
      position: relative;
      z-index: 2;
    }

    .signup-card {
      max-width: 500px;
      width: 100%;
    }

    .btn-social { width: 100%; margin-bottom: 10px; }

    /* slight translucent card so background shows through */
    .card.shadow-sm {
      background: rgba(10, 12, 16, 0.75);
      color: #e6eef8;
      border: 1px solid rgba(255,255,255,0.04);
      backdrop-filter: blur(6px);
    }

    /* small responsive tweaks */
    @media (max-width: 576px) {
      .card-body { padding: 1.5rem; }
    }

    /* optional: subtle vignette to enhance depth */
    #vignette {
      position: fixed;
      inset: 0;
      z-index: 1;
      pointer-events: none;
      background: radial-gradient(60% 60% at 50% 40%, rgba(255,255,255,0.02), rgba(0,0,0,0.6));
    }
  </style>
</head>
<body>
  <!-- Galaxy canvas container -->
  <div id="galaxy-canvas-wrap" aria-hidden="true"></div>
  <div id="vignette" aria-hidden="true"></div>

  <!-- Your signup UI (kept mostly intact, slightly adjusted classes) -->
  <div class="signup-container">
    <div class="signup-card">
      <div class="text-center mb-4">
        <a href="/index" class="text-decoration-none">
          <h2 style="font-weight: 700; color: #fff;">BLKND</h2>
        </a>
        <p class="text-muted" style="color: #c7d2e0;">Create your account to get started.</p>
      </div>
<!-- 
      <div class="card shadow-sm">
        <div class="card-body p-5">
          <form method="POST" action="/signup">
            <!-- server-side validation area (kept) -->
            <% if (errors && errors.length > 0) {
                const error = errors.find(err => ['fullName', 'email', 'phoneNumber', 'password', 'confirmPassword'].includes(err.path));
                if(error) {%>
                <div class="validation-wrapper mb-3">
                  <div class="validation-error">
                    <i class="bi bi-exclamation-circle"></i>
                    <span><%= error.msg %></span>
                  </div>
                </div>
            <% } } %>

            <div class="row">
              <div class="mb-3">
                <label class="form-label">Full Name</label>
                <input type="text" name="fullName" class="form-control" placeholder="Full name" required>
              </div>
              <div class="mb-3">
                <label class="form-label">Email Address</label>
                <input type="email" name="email" class="form-control" placeholder="Enter your email" required>
              </div>
              <div class="mb-3">
                <label class="form-label">Phone Number</label>
                <input type="tel" name="phoneNumber" class="form-control" placeholder="Enter your phone number" required>
              </div>
              <div class="mb-3">
                <label class="form-label">Password</label>
                <input type="password" name="password" class="form-control" placeholder="Create a password" required>
              </div>
              <div class="mb-3">
                <label class="form-label">Confirm Password</label>
                <input type="password" name="confirmPassword" class="form-control" placeholder="Confirm your password" required>
              </div>

              <div class="form-check mb-4">
                <input class="form-check-input" type="checkbox" id="terms" >
                <label class="form-check-label" for="terms">
                  I agree to the <a href="#">Terms & Conditions</a> and <a href="#">Privacy Policy</a>
                </label>
              </div>

              <button type="submit" class="btn btn-dark btn-lg w-100 mb-3">Create Account</button>
            </div>
          </form>

          <div class="text-center mb-3">
            <span class="text-muted">or sign up with</span>
          </div>

          <form method="GET" action="/auth/google/signup">
            <button class="btn btn-outline-dark btn-social" >
              <i class="fab fa-google"></i> Continue with Google
            </button>
          </form>

          <button class="btn btn-outline-dark btn-social">
            <i class="fab fa-facebook"></i> Continue with Facebook
          </button>

          <div class="text-center mt-4">
            <p class="mb-0">Already have an account? <a href="/login" class="text-decoration-none fw-bold">Login</a></p>
          </div>
        </div>
      </div>

      <div class="text-center mt-4">
        <a href="/index" class="text-decoration-none">
          <i class="fas fa-arrow-left"></i> Back to Home
        </a>
      </div>
    </div>
  </div> -->

  <!-- three.js (r152) -->
  <script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>

  <script>
  (function () {
    // Basic scene / renderer / camera setup
    const wrap = document.getElementById('galaxy-canvas-wrap');
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.domElement.style.display = 'block';
    wrap.appendChild(renderer.domElement);

    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 2000);
    camera.position.set(0, 10, 120);

    // We'll use a parent group to apply mouse-driven parallax/rotation
    const galaxyGroup = new THREE.Group();
    scene.add(galaxyGroup);

    // Utility: create a circular sprite texture using canvas (for stars)
    function createStarTexture(size = 64) {
      const c = document.createElement('canvas');
      c.width = c.height = size;
      const ctx = c.getContext('2d');

      const grad = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
      grad.addColorStop(0, 'rgba(255,255,255,1)');
      grad.addColorStop(0.2, 'rgba(255,240,220,0.9)');
      grad.addColorStop(0.4, 'rgba(200,220,255,0.6)');
      grad.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, size, size);
      return new THREE.CanvasTexture(c);
    }
    const starTexture = createStarTexture(128);

    // ===== MAIN PARTICLE GALAXY (arms, stars) =====
    function createGalaxy({count=50000, arms=4, radius=65, randomness=0.6, armSpread=0.8}) {
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(count * 3);
      const colors = new Float32Array(count * 3);
      const sizes = new Float32Array(count);

      const colorInside = new THREE.Color(0xfff4df); // warm core
      const colorOutside = new THREE.Color(0x88bbff); // bluish edges

      for (let i=0; i<count; i++) {
        const i3 = i*3;
        // radius for this star (0..radius)
        const r = Math.pow(Math.random(), 1.2) * radius;
        // pick arm and angle
        const armAngle = ( (i % arms) / arms ) * Math.PI * 2;
        // angle along arm
        const spin = r * (Math.random() * 0.4 + 0.2); // twisting
        const theta = armAngle + spin;
        // random offset perpendicular to arm
        const randomX = (Math.random() - 0.5) * randomness * (1 - r / radius) * armSpread * 10;
        const randomY = (Math.random() - 0.5) * randomness * (1 - r / radius) * 6;
        const randomZ = (Math.random() - 0.5) * randomness * (1 - r / radius) * armSpread * 8;

        positions[i3 + 0] = Math.cos(theta) * r + randomX;
        positions[i3 + 1] = randomY * 0.5; // squash a bit vertically
        positions[i3 + 2] = Math.sin(theta) * r + randomZ;

        // color lerp between core and outside based on r/radius
        const t = r / radius;
        const col = colorInside.clone().lerp(colorOutside, t);
        colors[i3 + 0] = col.r;
        colors[i3 + 1] = col.g;
        colors[i3 + 2] = col.b;

        // size varies
        sizes[i] = Math.max(0.5, (1 - t) * (Math.random() * 3 + 0.5));
      }

      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('aColor', new THREE.BufferAttribute(colors, 3));
      geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

      // Points material using custom vertex shader to use size attribute and color
      const material = new THREE.ShaderMaterial({
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
        vertexShader: `
          attribute float size;
          attribute vec3 aColor;
          varying vec3 vColor;
          void main() {
            vColor = aColor;
            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
            gl_PointSize = size * ( 300.0 / -mvPosition.z ); // size attenuation
            gl_Position = projectionMatrix * mvPosition;
          }
        `,
        fragmentShader: `
          uniform sampler2D uSprite;
          varying vec3 vColor;
          void main() {
            vec4 tex = texture2D(uSprite, gl_PointCoord);
            // premultiply color and alpha for smoother glow
            gl_FragColor = vec4(vColor, 1.0) * tex;
            // discard very transparent pixels for crisp edges
            if (gl_FragColor.a < 0.02) discard;
          }
        `,
        uniforms: {
          uSprite: { value: starTexture }
        }
      });

      const points = new THREE.Points(geometry, material);
      return points;
    }

    // Create galaxy and add to group
    const galaxy = createGalaxy({count: 38000, arms: 4, radius: 85, randomness: 0.9, armSpread: 0.9});
    galaxy.rotation.x = -0.15;
    galaxyGroup.add(galaxy);

    // ===== DUST LAYER (many faint particles for depth) =====
    function createDustLayer(count = 20000, spread = 220, size=1.8) {
      const geom = new THREE.BufferGeometry();
      const pos = new Float32Array(count * 3);
      const col = new Float32Array(count * 3);

      for (let i=0;i<count;i++){
        const i3 = i*3;
        pos[i3+0] = (Math.random() - 0.5) * spread;
        pos[i3+1] = (Math.random() - 0.5) * spread * 0.3;
        pos[i3+2] = (Math.random() - 0.5) * spread;
        const c = 0.6 + Math.random()*0.4;
        col[i3+0] = c; col[i3+1] = c; col[i3+2] = c;
      }

      geom.setAttribute('position', new THREE.BufferAttribute(pos, 3));
      geom.setAttribute('color', new THREE.BufferAttribute(col, 3));

      const mat = new THREE.PointsMaterial({
        size: size,
        map: starTexture,
        vertexColors: true,
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
        opacity: 0.28
      });

      const pts = new THREE.Points(geom, mat);
      pts.rotation.x = -0.15;
      return pts;
    }
    const dust = createDustLayer(14000, 260, 1.8);
    galaxyGroup.add(dust);

    // ===== SOFT NEBULA CLOUDS (large sprites with radial gradients) =====
    function createNebulaSprite(color1, color2, sizePx = 700) {
      const c = document.createElement('canvas');
      c.width = c.height = sizePx;
      const ctx = c.getContext('2d');

      // center radial gradient
      const g = ctx.createRadialGradient(sizePx/2, sizePx/2, 0, sizePx/2, sizePx/2, sizePx/2);
      g.addColorStop(0.0, color1);
      g.addColorStop(0.35, color2);
      g.addColorStop(1.0, 'rgba(0,0,0,0)');
      ctx.fillStyle = g;
      ctx.fillRect(0,0,sizePx,sizePx);

      const tex = new THREE.CanvasTexture(c);
      tex.needsUpdate = true;
      const mat = new THREE.SpriteMaterial({
        map: tex,
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
        opacity: 0.45
      });
      const sprite = new THREE.Sprite(mat);
      sprite.scale.set(80, 80, 1);
      return sprite;
    }

    const neb1 = createNebulaSprite('rgba(200,160,255,0.98)','rgba(120,80,180,0.28)', 1200);
    neb1.position.set(-40, 10, -40);
    neb1.scale.multiplyScalar(1.6);
    galaxyGroup.add(neb1);

    const neb2 = createNebulaSprite('rgba(255,220,180,0.88)','rgba(200,140,90,0.18)', 1100);
    neb2.position.set(55, -5, -20);
    neb2.scale.multiplyScalar(1.4);
    galaxyGroup.add(neb2);

    const neb3 = createNebulaSprite('rgba(160,200,255,0.9)','rgba(80,120,200,0.16)', 1500);
    neb3.position.set(10, -20, -80);
    neb3.scale.multiplyScalar(2.0);
    galaxyGroup.add(neb3);

    // tiny subtle ambient glow near center
    const coreSprite = createNebulaSprite('rgba(255,255,220,0.98)','rgba(255,200,120,0.06)', 900);
    coreSprite.position.set(0, 2, -6);
    coreSprite.scale.set(25, 25, 1);
    galaxyGroup.add(coreSprite);

    // ===== MOUSE INTERACTION (parallax-like) =====
    const mouse = {x: 0, y: 0};
    let targetRotX = 0, targetRotY = 0;
    const onMove = (e) => {
      // support touch and mouse
      const clientX = (e.touches ? e.touches[0].clientX : e.clientX);
      const clientY = (e.touches ? e.touches[0].clientY : e.clientY);
      mouse.x = (clientX / window.innerWidth) * 2 - 1;
      mouse.y = (clientY / window.innerHeight) * 2 - 1;
      // map to small rotation targets
      targetRotY = mouse.x * 0.12; // yaw
      targetRotX = mouse.y * 0.06; // pitch
    };
    window.addEventListener('pointermove', onMove, {passive: true});
    window.addEventListener('touchmove', onMove, {passive: true});

    // subtle camera bobbing for life
    let clock = new THREE.Clock();

    // resize handling
    window.addEventListener('resize', () => {
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
    });

    // render loop
    function animate() {
      const t = clock.getElapsedTime();

      // smooth rotation toward target (lerp)
      galaxyGroup.rotation.y += (targetRotY - galaxyGroup.rotation.y) * 0.06;
      galaxyGroup.rotation.x += (targetRotX - galaxyGroup.rotation.x) * 0.04;

      // slow global spin & slight up/down oscillation
      galaxy.rotation.y += 0.0008;
      galaxy.rotation.x = -0.15 + Math.sin(t * 0.12) * 0.002;
      dust.rotation.y += 0.0009;

      // animate nebula opacity & subtle drift
      neb1.material.opacity = 0.42 + Math.sin(t * 0.2) * 0.06;
      neb2.material.opacity = 0.34 + Math.cos(t * 0.18) * 0.05;
      neb3.material.opacity = 0.32 + Math.sin(t * 0.13) * 0.04;

      neb1.position.x += Math.cos(t * 0.02) * 0.01;
      neb2.position.z += Math.sin(t * 0.018) * 0.03;
      neb3.position.y += Math.cos(t * 0.016) * 0.02;

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate();

    // performance-friendly: pause when tab not visible
    document.addEventListener('visibilitychange', function() {
      if (document.hidden) renderer.setAnimationLoop(null);
      else animatorResume();
    });

    function animatorResume(){
      // ensure animate loop is running
      requestAnimationFrame(animate);
    }

    // Minor optimization: lower particle count on small screens
    if (window.innerWidth < 900) {
      // scale down counts
      // For mobile, remove heavy dust layer
      galaxyGroup.remove(dust);
      neb1.scale.multiplyScalar(0.8);
      neb2.scale.multiplyScalar(0.8);
      neb3.scale.multiplyScalar(0.8);
      camera.position.set(0, 8, 110);
    }
  })();
  </script>

  <!-- bootstrap bundle kept -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
